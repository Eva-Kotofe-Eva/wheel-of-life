<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Колесо жизненного баланса — Есть & Хочу (без библиотек)</title>
<style>
  :root{
    --card-bg: rgba(255,255,255,.80);
    --card-border: rgba(255,255,255,.35);
    --shadow: 0 20px 60px rgba(0,0,0,.15);
    --accent: #6c8cff;

    --cur-line:#506EFF;  --cur-fill: rgba(125,164,255,.26);
    --want-line:#FF69B4; --want-fill: rgba(255,105,180,.10);
  }
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; color:#1d2433;
    background:
      radial-gradient(1200px 700px at 10% -10%, #e3f2ff 0%, transparent 60%),
      radial-gradient(900px 600px at 100% 0%, #ffe8f1 0%, transparent 55%),
      radial-gradient(800px 500px at 0% 100%, #e9ffe9 0%, transparent 50%),
      linear-gradient(180deg, #f7f9fc 0%, #f1f5ff 100%);
  }
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:32px}
  .card{width:min(1200px,96vw);background:var(--card-bg);border:1px solid var(--card-border);
        border-radius:28px;box-shadow:var(--shadow);backdrop-filter:blur(12px);padding:22px}
  .header{display:flex;justify-content:space-between;align-items:center;border-bottom:1px dashed rgba(0,0,0,.08);padding-bottom:12px;gap:12px}
  .buttons{display:flex;gap:8px;flex-wrap:wrap}
  button{border:1px solid rgba(0,0,0,.08);background:#fff;border-radius:12px;padding:10px 14px;cursor:pointer}
  button.primary{background:var(--accent);color:#fff;border-color:transparent}

  .grid{display:grid;grid-template-columns:1.05fr 1fr;gap:18px;margin-top:16px}
  @media (max-width:960px){ .grid{grid-template-columns:1fr}}
  .panel{background:#fff;border:1px solid rgba(0,0,0,.06);border-radius:18px;padding:14px}

  .hdr{display:grid;grid-template-columns:1fr 110px 110px;gap:8px;font-size:12px;color:#556;margin-bottom:4px}
  @media (max-width:720px){ .hdr{grid-template-columns:1fr 90px 90px} }
  .inputs{display:grid;grid-template-columns:1fr;gap:8px}
  .row{display:grid;grid-template-columns:1fr 110px 110px;gap:8px;align-items:center}
  @media (max-width:720px){ .row{grid-template-columns:1fr 90px 90px} }
  .row input{border:1px solid #dde3ee;border-radius:10px;padding:8px 10px;font-size:14px;width:100%}
  .label{font-size:13px}

  .chart-wrap{height:560px}
  svg{width:100%;height:100%;touch-action:none}
  .handle{cursor:grab}
  .dragging .handle{cursor:grabbing}

  .legend{display:flex;gap:14px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:#445}
  .dot{width:12px;height:12px;border-radius:999px;display:inline-block;border:1px solid rgba(0,0,0,.1);margin-right:6px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="header">
      <h2 style="margin:0">Колесо жизненного баланса — Есть & Хочу</h2>
      <div class="buttons">
        <button class="primary" id="btnUpdate">Обновить</button>
        <button id="btnReset">Сбросить</button>
        <button id="btnSave">Сохранить PNG</button>
      </div>
    </div>

    <div class="grid">
      <!-- Левая панель: поля -->
      <div class="panel">
        <div class="hdr"><div></div><div>Есть</div><div>Хочу</div></div>
        <div class="inputs" id="inputs"></div>
        <div class="legend" id="legend"></div>
      </div>

      <!-- Правая панель: SVG колесо -->
      <div class="panel chart-wrap">
        <svg id="wheel" viewBox="0 0 680 680"></svg>
      </div>
    </div>
  </div>
</div>

<script>
const AREAS = [
  "Духовность / ценности",
  "Деньги и финансы",
  "Карьера и работа",
  "Здоровье и фитнес",
  "Отдых и хобби",
  "Окружающая среда",
  "Друзья / сообщество",
  "Семья",
  "Партнёрство и любовь",
  "Рост и развитие"
];
const COLORS = ["#B6E2D3","#FAD6A5","#C7CEEA","#FFD1DC","#B4F8C8","#FBE7C6","#A0E7E5","#FFDAC1","#D5AAFF","#FFB7B2"];

const N = AREAS.length;
const w=680,h=680,cx=w/2,cy=h/2;
const R0=45, R=270; // внутренний и внешний радиус

// Данные
let have = Array(N).fill(5);
let want = Array(N).fill(8);

// DOM
const svg = document.getElementById('wheel');
const inputsBox = document.getElementById('inputs');
const legendBox = document.getElementById('legend');
const inputs = {}; // inputs[name] = {have, want}

// Рендер полей и легенды
AREAS.forEach((name,i)=>{
  const row = document.createElement('div');
  row.className='row';
  row.innerHTML = `<div class="label">${name}</div>
                   <input type="number" min="0" max="10" step="0.5" value="${have[i]}">
                   <input type="number" min="0" max="10" step="0.5" value="${want[i]}">`;
  inputsBox.appendChild(row);
  const [lab, ih, iw] = row.children;
  inputs[name] = {have: ih, want: iw};
  ih.addEventListener('input',()=>{ have[i]=clamp(parseFloat(ih.value)); update(); });
  iw.addEventListener('input',()=>{ want[i]=clamp(parseFloat(iw.value)); update(); });

  const lg = document.createElement('span');
  lg.innerHTML = `<i class="dot" style="background:${COLORS[i]}"></i>${name}`;
  legendBox.appendChild(lg);
});

// Вспомогательные
const ang = i => -Math.PI/2 + i*2*Math.PI/N;
const valToR = v => R0 + (R-R0)*(v/10);
const clamp = v => isNaN(v)?0:Math.max(0,Math.min(10,v));
const round05 = v => Math.round(v*2)/2;
const XY = (r,a) => [cx + r*Math.cos(a), cy + r*Math.sin(a)];

// SVG элементы
const gSectors = el('g',{});
const gGrid    = el('g',{});
const gAxes    = el('g',{});
const gPolys   = el('g',{});
const gHandles = el('g',{});
svg.append(gSectors,gGrid,gAxes,gPolys,gHandles);

// Секторы (разноцветный фон)
for(let i=0;i<N;i++){
  const a1 = ang(i), a2 = ang(i+1);
  const [x1,y1]=XY(R,a1), [x2,y2]=XY(R,a2);
  const d = `M ${cx} ${cy} L ${x1} ${y1} A ${R} ${R} 0 0 1 ${x2} ${y2} Z`;
  gSectors.append( el('path',{d, fill: COLORS[i], opacity:.32, stroke:'none'}) );
}

// Радиальные круги и оси
for(let k=1;k<=10;k++){
  const r = R0 + (R-R0)*k/10;
  gGrid.append( el('circle',{cx,cy,r, fill:'none', stroke:'rgba(0,0,0,.08)'}));
}
for(let i=0;i<N;i++){
  const a = ang(i);
  const [x1,y1]=XY(R0,a), [x2,y2]=XY(R,a);
  gAxes.append(el('line',{x1,y1,x2,y2, stroke:'rgba(0,0,0,.18)'}));

  // подписи в 1–2 строки
  const [lx,ly]=XY(R+20,a);
  const t = el('text',{
    x: lx, y: ly, 'font-size': 12, 'text-anchor': Math.cos(a)>0? 'start':'end',
    'dominant-baseline':'middle', fill:'#233'
  });
  const lines = wrap2(AREAS[i]);
  t.append(el('tspan',{x:lx,dy:0}, lines[0]));
  if(lines[1]) t.append(el('tspan',{x:lx,dy:14}, lines[1]));
  gAxes.append(t);
}

// Полигоны
const polyHave = el('polygon',{fill:'var(--cur-fill)', stroke:'var(--cur-line)', 'stroke-width':2});
const polyWant = el('polygon',{fill:'var(--want-fill)', stroke:'var(--want-line)', 'stroke-width':2});
gPolys.append(polyHave, polyWant);

// Хэндлы
const handlesHave=[], handlesWant=[];
for(let i=0;i<N;i++){
  const c1 = el('circle',{r:7, fill:'var(--cur-line)', stroke:'#fff','stroke-width':1,class:'handle','data-ds':'have','data-i':i});
  const c2 = el('circle',{r:7, fill:'var(--want-line)',stroke:'#fff','stroke-width':1,class:'handle','data-ds':'want','data-i':i});
  handlesHave.push(c1); handlesWant.push(c2);
  gHandles.append(c1,c2);
}

// Обновление геометрии
function update(){
  // синхронизация инпутов
  AREAS.forEach((n,i)=>{ inputs[n].have.value = have[i]; inputs[n].want.value = want[i]; });

  // точки полигонов
  const ptsHave = [], ptsWant = [];
  for(let i=0;i<N;i++){
    const a = ang(i);
    let [x,y] = XY(valToR(have[i]), a); ptsHave.push(`${x},${y}`);
    [x,y] = XY(valToR(want[i]), a); ptsWant.push(`${x},${y}`);
  }
  polyHave.setAttribute('points', ptsHave.join(' '));
  polyWant.setAttribute('points', ptsWant.join(' '));

  // хэндлы
  for(let i=0;i<N;i++){
    const a = ang(i);
    let [x1,y1] = XY(valToR(have[i]), a);
    let [x2,y2] = XY(valToR(want[i]), a);
    handlesHave[i].setAttribute('cx',x1); handlesHave[i].setAttribute('cy',y1);
    handlesWant[i].setAttribute('cx',x2); handlesWant[i].setAttribute('cy',y2);
  }
}
update();

// Drag (мышь/тач)
let dragging = null; // {ds:'have'|'want', i:number}
svg.addEventListener('mousedown',startDrag);
svg.addEventListener('touchstart',startDrag,{passive:false});
window.addEventListener('mousemove',moveDrag);
window.addEventListener('touchmove',moveDrag,{passive:false});
window.addEventListener('mouseup',endDrag);
window.addEventListener('touchend',endDrag);

function startDrag(e){
  const target = e.target;
  if(target.classList && target.classList.contains('handle')){
    dragging = { ds: target.getAttribute('data-ds'), i: +target.getAttribute('data-i') };
    svg.classList.add('dragging');
    e.preventDefault();
  }
}
function moveDrag(e){
  if(!dragging) return;
  const pt = clientToSvg(e);
  const i = dragging.i;
  const a = ang(i);
  const ux = Math.cos(a), uy = Math.sin(a);
  // проекция указателя на луч
  const vx = pt.x - cx, vy = pt.y - cy;
  let radial = vx*ux + vy*uy; // скалярная проекция
  radial = Math.max(R0, Math.min(R, radial));
  const value = (radial - R0)/(R - R0)*10;
  const v = round05(value);
  if(dragging.ds==='have'){ have[i]=v; } else { want[i]=v; }
  update();
  e.preventDefault();
}
function endDrag(){ dragging=null; svg.classList.remove('dragging'); }

// Кнопки
document.getElementById('btnUpdate').onclick = ()=> update();
document.getElementById('btnReset').onclick = ()=>{
  have = Array(N).fill(5); want = Array(N).fill(8); update();
};
document.getElementById('btnSave').onclick = ()=> savePng();

// Утилиты
function el(tag, attrs={}, text){
  const n = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for(const k in attrs){ n.setAttribute(k, attrs[k]); }
  if(text!=null) n.textContent=text;
  return n;
}
function wrap2(s){
  // разбиение подписи максимум на 2 строки
  if(s.length<=16) return [s];
  const parts = s.split(' ');
  if(parts.length===1) return [s]; // одно длинное слово
  const mid = Math.ceil(parts.length/2);
  return [parts.slice(0,mid).join(' '), parts.slice(mid).join(' ')];
}
function clientToSvg(e){
  const pt = svg.createSVGPoint();
  const t = e.touches ? e.touches[0] : e;
  pt.x = t.clientX; pt.y = t.clientY;
  const ctm = svg.getScreenCTM().inverse();
  return pt.matrixTransform(ctm);
}

// Экспорт PNG
function savePng(){
  const serializer = new XMLSerializer();
  const clone = svg.cloneNode(true);
  // белый фон под SVG
  const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
  bg.setAttribute('x',0); bg.setAttribute('y',0); bg.setAttribute('width','100%'); bg.setAttribute('height','100%');
  bg.setAttribute('fill','#ffffff');
  clone.insertBefore(bg, clone.firstChild);
  const svgStr = serializer.serializeToString(clone);
  const img = new Image();
  const svgBlob = new Blob([svgStr], {type:'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(svgBlob);
  img.onload = function(){
    const canvas = document.createElement('canvas');
    canvas.width = 1200; canvas.height = 1200;
    const ctx = canvas.getContext('2d');
    // фон страницы (градиенты) не трогаем — экспортируем чистое колесо
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
    // впишем SVG в квадрат
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    URL.revokeObjectURL(url);
    const a = document.createElement('a');
    a.download = 'wheel_of_life.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
  };
  img.src = url;
}
</script>
</body>
</html>

